export interface ExportOptions {
  format: "stl" | "obj" | "ply"
  quality: "low" | "medium" | "high"
  includeOriginal: boolean
  includeCylinders: boolean
  compression: boolean
  metadata: boolean
  units: "mm" | "cm" | "inches"
}

export interface Point {
  id: string
  position: [number, number, number]
  type: string
  timestamp: number
}

// STL File Generator
export function generateSTLFile(points: Point[], originalFile: File | null, options: ExportOptions): string {
  const header = "solid ScanLadderExport\n"
  const footer = "endsolid ScanLadderExport\n"

  let content = header

  // Add metadata as comments if enabled
  if (options.metadata) {
    content += `# Generated by Scan Ladder\n`
    content += `# Export Date: ${new Date().toISOString()}\n`
    content += `# Points: ${points.length}\n`
    content += `# Quality: ${options.quality}\n`
    content += `# Units: ${options.units}\n`
    content += `# Original File: ${originalFile?.name || "None"}\n`
  }

  // Generate cylinders for each point
  if (options.includeCylinders && points.length > 0) {
    points.forEach((point, index) => {
      const [x, y, z] = point.position
      const radius = point.type === "hs-cap-small" ? 0.8 : 1.0
      const height = 2.0
      const segments = options.quality === "high" ? 16 : options.quality === "medium" ? 12 : 8

      // Generate cylinder geometry
      for (let i = 0; i < segments; i++) {
        const angle1 = (i / segments) * Math.PI * 2
        const angle2 = ((i + 1) / segments) * Math.PI * 2

        const x1 = x + Math.cos(angle1) * radius
        const y1 = y
        const z1 = z + Math.sin(angle1) * radius

        const x2 = x + Math.cos(angle2) * radius
        const y2 = y
        const z2 = z + Math.sin(angle2) * radius

        const x3 = x + Math.cos(angle1) * radius
        const y3 = y + height
        const z3 = z + Math.sin(angle1) * radius

        const x4 = x + Math.cos(angle2) * radius
        const y4 = y + height
        const z4 = z + Math.sin(angle2) * radius

        // Bottom face
        content += `  facet normal 0.0 -1.0 0.0\n`
        content += `    outer loop\n`
        content += `      vertex ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`
        content += `      vertex ${x1.toFixed(6)} ${y1.toFixed(6)} ${z1.toFixed(6)}\n`
        content += `      vertex ${x2.toFixed(6)} ${y2.toFixed(6)} ${z2.toFixed(6)}\n`
        content += `    endloop\n`
        content += `  endfacet\n`

        // Top face
        content += `  facet normal 0.0 1.0 0.0\n`
        content += `    outer loop\n`
        content += `      vertex ${x.toFixed(6)} ${(y + height).toFixed(6)} ${z.toFixed(6)}\n`
        content += `      vertex ${x4.toFixed(6)} ${y4.toFixed(6)} ${z4.toFixed(6)}\n`
        content += `      vertex ${x3.toFixed(6)} ${y3.toFixed(6)} ${z3.toFixed(6)}\n`
        content += `    endloop\n`
        content += `  endfacet\n`

        // Side faces
        const nx = Math.cos((angle1 + angle2) / 2)
        const nz = Math.sin((angle1 + angle2) / 2)

        content += `  facet normal ${nx.toFixed(6)} 0.0 ${nz.toFixed(6)}\n`
        content += `    outer loop\n`
        content += `      vertex ${x1.toFixed(6)} ${y1.toFixed(6)} ${z1.toFixed(6)}\n`
        content += `      vertex ${x3.toFixed(6)} ${y3.toFixed(6)} ${z3.toFixed(6)}\n`
        content += `      vertex ${x4.toFixed(6)} ${y4.toFixed(6)} ${z4.toFixed(6)}\n`
        content += `    endloop\n`
        content += `  endfacet\n`

        content += `  facet normal ${nx.toFixed(6)} 0.0 ${nz.toFixed(6)}\n`
        content += `    outer loop\n`
        content += `      vertex ${x1.toFixed(6)} ${y1.toFixed(6)} ${z1.toFixed(6)}\n`
        content += `      vertex ${x4.toFixed(6)} ${y4.toFixed(6)} ${z4.toFixed(6)}\n`
        content += `      vertex ${x2.toFixed(6)} ${y2.toFixed(6)} ${z2.toFixed(6)}\n`
        content += `    endloop\n`
        content += `  endfacet\n`
      }
    })
  }

  // Add original file data placeholder if included
  if (options.includeOriginal && originalFile) {
    content += `# Original file data would be merged here\n`
    content += `# File: ${originalFile.name}\n`
    content += `# Size: ${originalFile.size} bytes\n`
  }

  content += footer
  return content
}

// OBJ File Generator
export function generateOBJFile(points: Point[], originalFile: File | null, options: ExportOptions): string {
  let content = "# OBJ file generated by Scan Ladder\n"

  if (options.metadata) {
    content += `# Export Date: ${new Date().toISOString()}\n`
    content += `# Points: ${points.length}\n`
    content += `# Quality: ${options.quality}\n`
    content += `# Units: ${options.units}\n`
    content += `# Original File: ${originalFile?.name || "None"}\n`
  }

  content += "\n"

  let vertexIndex = 1

  if (options.includeCylinders && points.length > 0) {
    points.forEach((point, pointIndex) => {
      const [x, y, z] = point.position
      const radius = point.type === "hs-cap-small" ? 0.8 : 1.0
      const height = 2.0
      const segments = options.quality === "high" ? 16 : options.quality === "medium" ? 12 : 8

      content += `# Cylinder ${pointIndex + 1}\n`
      content += `g cylinder_${pointIndex + 1}\n`

      // Generate vertices
      const startVertex = vertexIndex

      // Bottom center
      content += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`
      vertexIndex++

      // Top center
      content += `v ${x.toFixed(6)} ${(y + height).toFixed(6)} ${z.toFixed(6)}\n`
      vertexIndex++

      // Bottom circle vertices
      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2
        const vx = x + Math.cos(angle) * radius
        const vz = z + Math.sin(angle) * radius
        content += `v ${vx.toFixed(6)} ${y.toFixed(6)} ${vz.toFixed(6)}\n`
        vertexIndex++
      }

      // Top circle vertices
      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2
        const vx = x + Math.cos(angle) * radius
        const vz = z + Math.sin(angle) * radius
        content += `v ${vx.toFixed(6)} ${(y + height).toFixed(6)} ${vz.toFixed(6)}\n`
        vertexIndex++
      }

      // Generate faces
      // Bottom faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        content += `f ${startVertex} ${startVertex + 2 + i} ${startVertex + 2 + next}\n`
      }

      // Top faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        content += `f ${startVertex + 1} ${startVertex + 2 + segments + next} ${startVertex + 2 + segments + i}\n`
      }

      // Side faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        const b1 = startVertex + 2 + i
        const b2 = startVertex + 2 + next
        const t1 = startVertex + 2 + segments + i
        const t2 = startVertex + 2 + segments + next

        content += `f ${b1} ${t1} ${t2}\n`
        content += `f ${b1} ${t2} ${b2}\n`
      }

      content += "\n"
    })
  }

  return content
}

// PLY File Generator
export function generatePLYFile(points: Point[], originalFile: File | null, options: ExportOptions): string {
  const vertices: string[] = []
  const faces: string[] = []
  let vertexCount = 0
  let faceCount = 0

  if (options.includeCylinders && points.length > 0) {
    points.forEach((point) => {
      const [x, y, z] = point.position
      const radius = point.type === "hs-cap-small" ? 0.8 : 1.0
      const height = 2.0
      const segments = options.quality === "high" ? 16 : options.quality === "medium" ? 12 : 8

      const startVertex = vertexCount

      // Bottom center
      vertices.push(`${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}`)
      vertexCount++

      // Top center
      vertices.push(`${x.toFixed(6)} ${(y + height).toFixed(6)} ${z.toFixed(6)}`)
      vertexCount++

      // Bottom circle vertices
      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2
        const vx = x + Math.cos(angle) * radius
        const vz = z + Math.sin(angle) * radius
        vertices.push(`${vx.toFixed(6)} ${y.toFixed(6)} ${vz.toFixed(6)}`)
        vertexCount++
      }

      // Top circle vertices
      for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2
        const vx = x + Math.cos(angle) * radius
        const vz = z + Math.sin(angle) * radius
        vertices.push(`${vx.toFixed(6)} ${(y + height).toFixed(6)} ${vz.toFixed(6)}`)
        vertexCount++
      }

      // Generate faces
      // Bottom faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        faces.push(`3 ${startVertex} ${startVertex + 2 + i} ${startVertex + 2 + next}`)
        faceCount++
      }

      // Top faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        faces.push(`3 ${startVertex + 1} ${startVertex + 2 + segments + next} ${startVertex + 2 + segments + i}`)
        faceCount++
      }

      // Side faces
      for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments
        const b1 = startVertex + 2 + i
        const b2 = startVertex + 2 + next
        const t1 = startVertex + 2 + segments + i
        const t2 = startVertex + 2 + segments + next

        faces.push(`3 ${b1} ${t1} ${t2}`)
        faces.push(`3 ${b1} ${t2} ${b2}`)
        faceCount += 2
      }
    })
  }

  let content = "ply\n"
  content += "format ascii 1.0\n"

  if (options.metadata) {
    content += `comment Generated by Scan Ladder\n`
    content += `comment Export Date: ${new Date().toISOString()}\n`
    content += `comment Points: ${points.length}\n`
    content += `comment Quality: ${options.quality}\n`
    content += `comment Units: ${options.units}\n`
    content += `comment Original File: ${originalFile?.name || "None"}\n`
  }

  content += `element vertex ${vertexCount}\n`
  content += "property float x\n"
  content += "property float y\n"
  content += "property float z\n"
  content += `element face ${faceCount}\n`
  content += "property list uchar int vertex_indices\n"
  content += "end_header\n"

  // Add vertices
  vertices.forEach((vertex) => {
    content += vertex + "\n"
  })

  // Add faces
  faces.forEach((face) => {
    content += face + "\n"
  })

  return content
}
